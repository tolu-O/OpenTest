"""
This is the skeleton code for homework 1. This contains several functions for
you to fill in; we have provided the function signatures and docstrings for
several functions which we implement in our autograder. Feel free to add any
additional functions that you need to complete the assignment.

As before, you are not allowed to import any third-party libraries other than
those already included in the Python standard library. This means you may not
use libraries like numpy, pandas, biopython, or biotite.

Do not modify the function names or signatures that are indicated as being
graded by the autograder, as you will break the autograder.
"""

import os, sys
import logging
import argparse

START_CODONS = ["ATG"]
STOP_CODONS = ["TAA", "TGA", "TAG"]

# Codons are mapped using "T" instead of "U".
CODON_TABLE = {
    "AAA": "K",
    "AAC": "N",
    "AAG": "K",
    "AAT": "N",
    "ACA": "T",
    "ACC": "T",
    "ACG": "T",
    "ACT": "T",
    "AGA": "R",
    "AGC": "S",
    "AGG": "R",
    "AGT": "S",
    "ATA": "I",
    "ATC": "I",
    "ATG": "M",
    "ATT": "I",
    "CAA": "Q",
    "CAC": "H",
    "CAG": "Q",
    "CAT": "H",
    "CCA": "P",
    "CCC": "P",
    "CCG": "P",
    "CCT": "P",
    "CGA": "R",
    "CGC": "R",
    "CGG": "R",
    "CGT": "R",
    "CTA": "L",
    "CTC": "L",
    "CTG": "L",
    "CTT": "L",
    "GAA": "E",
    "GAC": "D",
    "GAG": "E",
    "GAT": "D",
    "GCA": "A",
    "GCC": "A",
    "GCG": "A",
    "GCT": "A",
    "GGA": "G",
    "GGC": "G",
    "GGG": "G",
    "GGT": "G",
    "GTA": "V",
    "GTC": "V",
    "GTG": "V",
    "GTT": "V",
    "TAA": "*",
    "TAC": "Y",
    "TAG": "*",
    "TAT": "Y",
    "TCA": "S",
    "TCC": "S",
    "TCG": "S",
    "TCT": "S",
    "TGA": "*",
    "TGC": "C",
    "TGG": "W",
    "TGT": "C",
    "TTA": "L",
    "TTC": "F",
    "TTG": "L",
    "TTT": "F",
}

ACTR2_EXONS = "ggaagaagagaaaacggccgggcggcggtggctgtaggttgtgcggctgc,agcggctcttccctgggcggacgATGGACAGCCAGGGCAGGAAGGTGGTG,GTGTGCGACAACGGCACCGGG,TTTGTGAAGTGTGGATATGCAGGCTCTAACTTTCCAGAACACATCTTCCC,AGCTTTGGTTGGAAGACCTATTATCAGATCAACCACCAAAGTGGGAAACA,TTGAAATCAAG,AATAACAAAAAGATG,GATCTTATGGTTGGTGATGAGGCAAGTGAATTACGATCAATGTTAGAAGT,TAACTACCCTATGGAAAATGGCATAGTACGAAATTGGGATGACATGAAAC,ACCTGTGGGACTACACATTTGGACCAGAGAAACTTAATATAGATACCAGA,AATTGTAAAATCTTACTCACAGAACCTCCTATGAACCCAACCAAAAACAG,AGAGAAGATTGTAGAG,GTAATGTTTGAAACTTACCAGTTTTCCGGTGTATATGTAGCCATCCAGGC,AGTTCTGACTTTGTACGCTCAAG,GTTTATTGACTGGTGTAGTGGTAGACTCTGGAGATGGTGTGACTCACATT,TGCCCAGTATATGAAGGCTTTTCTCTCCCTCATCTTACCAGGAGACTGGA,TATTGCTGGGAGGGATATAACTAGATATCTTATCAAG,CTACTTCTGTTGCGAGGATACGCCTTCAACCACTCTGCTGATTTTGAAAC,GGTTCGCATGATTAAAGAAAAACTGTGTTACGTGGGATATAATATTGAGC,AAGAGCAGAAACTGGCCTTAGAAACCACAGTATTAGTTGAATCTTATACA,CTCCCAGATGGACGTATCATCAAAGTTGGGGGAGAGAGATTTGAAGCACC,AGAAGCTTTATTTCAGCCTCACTTGATCAATGTTGAAGGAGTTGGTGTTG,CTGAATTGCTTTTTAACACAATTCAGGCAGCTGACATTGATACCAG,ATCTGAATTCTACAAACACATTGTGCTTTCTGGAGGGTCTACTATGTATC,CTGGCCTGCCATCACGGTTGGAACGAGAACTTAAACAGCTTTACTTAGAA,CGAGTTTTGAAGGGTGATGTGGAAAAACTTTCT,AAATTTAAGATCCGCATTGAAGACCCACCCCGCAGAAAGCACATGGTATT,CCTGGGTGGTGCAGTTCTAGCGGATATCATGAAAGACAAAGACAACTTTT,GGATGACCCGACAAGAGTACCAAGAAAAGGGTGTCCGTGTGCTAGAGAAA,CTTGGTGTGACTGTTCGATAAactccaaagcttgttcccgtc".upper().split(
    ","
)
assert len(ACTR2_EXONS) == 30


def rev_comp(s, tolerate_errors=True):
    """Return the reverse complement of a sequence. This is provided for you."""
    s = s.upper()
    complements = {
        "A": "T",
        "T": "A",
        "C": "G",
        "G": "C",
        "N": "N",
    }
    if not tolerate_errors:
        return "".join([complements[base] for base in s[::-1]])
    else:
        # Replace unknown nucleotides with N
        complements = [
            "N" if base not in complements else complements[base] for base in s
        ]
        return "".join(complements[::-1])


def nt2aa(sequence):
    """
    Translate the given nucleotide sequence to amino acids. You should return
    an "M" character corresponding to the start codon, but NOT the "*" character
    corresponding to the stop codon. This function will NOT be tested by the
    autograder, but you may find it useful to implement anyway.

    >>> nt2aa("ATGCGTGTCAGCCCGTGA")
    'MRVSP'
    """
    raise NotImplementedError


def read_fasta(filename):
    """
    A fasta file is a plain text file that contains one more nucloeotide sequences.
    In a fasta file, the "header" describing a sequence is denoted by a ">" at
    the beginning of the line; that entire line is then considered to be a header.
    The sequence itself are all lines after the header line, until the occurrence
    of the next headder or the end of the file.

    In this function, you will implement some basic Python code to read in a fasta
    file, and return a dictionary mapping the each header to its corresponding
    sequence. This will NOT be tested by the autograder, but you will need it to
    run your code on input files.
    """

    nf = open(filename)
    sequence = ""

   
    for x in nf.readLines():    
        if ">" not in x:
            sequence = sequence + x
    print(sequence)

    return sequence


def nucleotide_counts(sequence):
    """
    Returns the count of each nucleotide in a sequence (as a string) as a
    dictionary. This function should be case insensitive, and count all
    character as if they are upper case. It should count all nucleotides
    regardless of whether they are one of the canonical nucleotides (ACGT).

    This will be tested by the autograder.

    >>> nucleotide_counts("ACGT")
    {'A': 1, 'C': 1, 'G': 1, 'T': 1}
    >>> nucleotide_counts("ACGTCCGTA")
    {'A': 2, 'C': 3, 'G': 2, 'T': 2}
    >>> nucleotide_counts("ACGTccgta")
    {'A': 2, 'C': 3, 'G': 2, 'T': 2}
    >>> nucleotide_counts("acgtN")
    {'A': 1, 'C': 1, 'G': 1, 'T': 1, 'N': 1}
    """
    sequence1 = sequence.upper()

    varA = 0
    varC = 0
    varG = 0
    varT = 0
    varN = 0
    varX = 0

    for x in sequence1:
        match x:
            case 'A':
                varA +=1
            case 'C':
                varC +=1
            case 'G':
                varG +=1
            case 'T':
                varT +=1
            case 'N':
                varN +=1
            case 'X':
                varX +=1

    if 'N' in sequence1:
        
        if 'X' in sequence1:
            dictA = {
            'A': varA,
            'C': varC,
            'G': varG,
            'T': varT,
            'N': varN,
            'X': varX
        }
        else:
            dictA = {
                'A': varA,
                'C': varC,
                'G': varG,
                'T': varT,
                'N': varN
            }
    else:
            dictA = {
            'A': varA,
            'C': varC,
            'G': varG,
            'T': varT
        }

    return dictA





#========= major function ro find orf for each strand and frame =================    
def strands_orfs(sequence, shift, sign):
    
    if shift ==1:
        sequence = sequence[1:]
    elif shift ==2:
        sequence = sequence[2:]
    
    
    
    #=========variables/dict/lists=================
    i=0 #keep count of codon in sequence
    orf = {} #dictionary to save orfs
    orfCount = 0 #for labelling key in orf dictionary
    seq=""
    longestOrf = "" #keep track of the longest orf
    longestOrfList = [] #used if more than one maximal orf
    p=0 #only used to ignore saving the first orf instance in the list twice
    start = 0 #reads sequence after ATG is read
    
    
    # print(sequence[i:i+3]) #debugging
    # print(len(sequence)) #debugging
    
    
    #==========save ORF into dictionary====================
    while i < len(sequence):
        # print("main: ",i, " ",sequence[i:i+3]) #debugging
        
        #if start codon, start reading sequence
        if sequence[i:i+3] in START_CODONS:
                start = 1
                # print("start") debugging
        
        
        #if start codon has been read
        if start == 1:
            
            #for each nucleotide in codon
            for x in sequence[i:i+3]:
                #if not a base nucleotide, stop sequence  
                if x not in ["A","C","G","T"]:
                    #reset seq
                    seq = ""
                    
                    #add new orf count used for dicitonary key
                    orfCount+=1
                    
                    #stop reading sequence
                    start = 0

                    # print("ignore") #debugging
                    
                    
            
            # print("codon1: ",sequence[i:i+3]) #debugging
            
            
            if start == 1:
                # stop sequence when stop codon is read
                if sequence[i:i+3] in STOP_CODONS:
                        #add stop codon to sequence
                        seq = seq + sequence[i:i+3]
                        
                        #orf dictionary key:value
                        orf["orf"+str(orfCount)]=seq
                        
                        # print("codon2: ",sequence[i:i+3]) #debugging
                        # print("orf: ", orf) #debugging
                        
                        #reset seq
                        
                        seq = ""
                        
                        #add new orf count used for dicitonary key
                        orfCount+=1
                       
                        #stop reading sequence
                        start = 0
                        # print("stop") #debugging
                
                
                #add codon to orf if stop codon has not been read      
                if sequence[i:i+3] not in STOP_CODONS:
                    seq = seq + sequence[i:i+3]   
        
        #move to next codon
        i+=3    #increase count used to identify codon   

    #=========get longest ORF========================

    for x in orf.values():
        p+=1
        #if a orf is the longest frame
        if len(x) > len(longestOrf):
            longestOrf = x
            
            #only include longest orf in list
            del longestOrfList
            longestOrfList = [] #rest list
            longestOrfList.append(longestOrf)
            
        
        
        if p != 1:
            #if more than 1 orf are equally maximal
            if len(x) == len(longestOrfList[0]):
                longestOrfList.append(x)
        
    
    return longestOrfList








def find_orfs(sequence, offsets=[0, 1, 2], strands=["+", "-"]):
    """
    Finds all ORFs in a sequence. Briefly, an ORF starts with a start codon and
    ends with a stop codon, and does not contain a stop codon in the middle of
    the sequence. Assume that the given sequence is on the + strand; you must
    also consider the reverse complement - strand. Please see the hw1 handout
    for a full details.

    This will be tested by the autograder.
    WARNING: changing the default values for the offsets or strands variables
    will lead to breaking autograder tests. Do NOT change these default values.

    >>> find_orfs('ATGAACTAA')
    ['ATGAACTAA']
    >>> find_orfs('ATGNNNATGAACTAA')  # Skip ORFs that contain non-ACTG bases
    ['ATGAACTAA']
    >>> find_orfs('ATGATGAACTAA')  # Return only longest ORF for a given stop codon
    ['ATGATGAACTAA']
    >>> find_orfs('ATGCGTGTCATGCTTTAA')
    ['ATGCGTGTCATGCTTTAA']
    >>> find_orfs("TTAGTTCATCAT")  # Reverse complement
    ['ATGATGAACTAA']
    >>> find_orfs('ATGAACTAAATGAACTAA')
    ['ATGAACTAA', 'ATGAACTAA']
    """

    # print("find orfs") #debugging
    #=========establish strands =================
    positive = sequence
    negative = rev_comp(sequence)
    
    # print("positive: ", positive) #debugging
    # print("negative: ", negative) #debugging
    # print(" ") #debugging
    
    #=========check all combinations =================
    finalList = []
    shift = 0
    
    if 0 in offsets:
        shift=0
        #add to finalList
        if "+" in strands:
            # print("1:",strands_orfs(positive,shift,"+")) #debugging
            finalList = finalList + strands_orfs(positive,shift,"+")
        if "-" in strands:
            # print("2:",strands_orfs(negative,shift,"-")) #debugging
            finalList = finalList + strands_orfs(negative,shift,"-")
    if 1 in offsets:
        shift=1
        #add to finalList
        if "+" in strands:
            # print("3:",strands_orfs(positive,shift,"+")) #debugging
            finalList = finalList + strands_orfs(positive,shift,"+")
        if "-" in strands:
            # print("4:",strands_orfs(negative,shift,"-")) #debugging
            finalList = finalList + strands_orfs(negative,shift,"-")
    if 2 in offsets:
        shift=2
        #add to finalList
        if "+" in strands:
            # print("5:",strands_orfs(positive,shift,"+")) #debugging
            finalList = finalList + strands_orfs(positive,shift,"+")
        if "-" in strands:
            # print("6:",finalList + strands_orfs(negative,shift,"-")) #debugging
            finalList = finalList + strands_orfs(negative,shift,"-")
            
            
    #return length of finalList to see # of ORF        
    # print("===================") #debugging
    # print(finalList) #debugging
    return finalList #returns single list containing all the ORFs found in all options selected (strands/offset)


def report_orf_statistics(filename):
    """
    Report the number of ORFs found in each sequence in a fasta file, for
    each of the 6 possible reading frames (3 forward, 3 reverse complement).

    This function is implemented for you as a convenience function, and will
    not be graded. You may modify it if you wish.
    """
    seqs = read_fasta(filename)
    for chrom, seq in seqs.items():
        nt_count = nucleotide_counts(seq)
        print(f"Chromosome {chrom}: {nt_count}")

        for strand in ["+", "-"]:
            for i in range(3):
                orfs = find_orfs(seq, offsets=[i], strands=[strand])
                print(f"{chrom}, strand {strand} offset +{i}: Found {len(orfs)} ORFs")


def alt_splice(sequence_list, binary_string):
    """
    This function takes in a sequence list, where each entry is a string of
    nucleotides, and a binary string of the same length where each entry is
    either 0 or 1, and returns the nucleotide sequence that results from
    dropping the exons corresponding to 0s in the binary string.

    This will be tested by the autograder.

    >>> alt_splice(['ATGCGT', 'CTAC', 'GTCAG', 'CCCGTGA'], '1011')
    'ATGCGTGTCAGCCCGTGA'
    """
    assert len(sequence_list) == len(binary_string)
    assert isinstance(binary_string, str)
    assert all([b in "01" for b in binary_string])

    newString=""
    i=0
    
    #for each item in the list - i.e. each exon
    for x in sequence_list:
        # print(x) #debugging
        # print(binary_string[i]) #debugging
        
        #if  corresponding index is 1, keep exon/add to final sequence
        if binary_string[i] == "1" :
            newString = newString + x
            i+=1
        else:
            i+=1
            continue
    
    #return final exon sequence
    return newString


def greedy_translation(sequence: str):
    """
    Translate a sequence into amino acids using a greedy approach. This works
    by scanning for the first start codon, and then translates the sequence
    until either it
    * Finds a stop codon, in which case it returns the amino acid sequence
    * Does not find a stop codon, in which it returns None

    This will be tested by the autograder.
    """
    
    i=0
    start=0
    finalProtein =""
    
    # print("origin: ",sequence) #debugging
    
    #==== get the index of where the first START CODON begins - ATG ======
    for x in sequence:
        if x == "A":
            if sequence[i+1]=="T":
                if sequence[i+2]=="G":
                    start=i
                    # print(sequence[i]+sequence[i+1]+sequence[i+2]) #debugging
                    break
        i+=1
    
    
    i=start  #speccify starting location
    # print("start: ",i) #debugging
    
    #======= from first START CODON, while no STOP CODON is found============
    while sequence[i:i+3] not in STOP_CODONS:

        #if codon can be found in codon table, save the amino acid it translates to
        if sequence[i:i+3] in CODON_TABLE:
            # print("seq: ",sequence[i:i+3]) #debugging
            protein = CODON_TABLE[sequence[i:i+3]]
            finalProtein = finalProtein + protein
        
        elif sequence[i:i+3] not in CODON_TABLE:
            # print("None") #debugging 
            return None

        i+=3  #count to check next 3 nucleotides          
        
    #if next codon is a stop codon, return amino acid sequence
    if sequence[i:i+3] in STOP_CODONS:
        # print("seq: ",sequence[i:i+3]) #debugging
        # print("final: ",finalProtein) #debugging
        return finalProtein
    else:
        return None

def actr2_alt_splicing():
    """
    This function is implemented for you as a convenience function. Feel free
    to modify or extend it to help with analyses.

    This will not be tested by the autograder.
    """
    # These are the same binary strings as those in the handout
    splice_binary_strings = [
        "000000000000000000000000000001",
        "000000000000000000000000000011",
        "000000000000000000000000001001",
        "000000100000000000000000001111",
        "100000100000000000000000001111",
        "111000100000000000000000001111",
        "111000100000000001111111111111",
        "111000100000000011111111111111",
        "111111111111111111111111111111",
        "111111111111111111111111111101",
        "111111111111111111111111111001",
    ]
    for binary_string in splice_binary_strings:
        nt_seq = alt_splice(ACTR2_EXONS, binary_string)
        aa_seq = greedy_translation(nt_seq)
        orfs = find_orfs(nt_seq, strands=["+"])


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    import doctest


    read_fasta('Homo_sapiens.GRCh38.dna.chromosome.22.fa')


    doctest.testmod(verbose=False)
